import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';

const ARCHESTRA_SERVER_BASE_URL = 'http://localhost:54587';

/**
 * Integration tests for SSE streaming functionality
 * Tests the agent chat endpoint and SSE event handling
 */
describe('SSE Streaming Integration Tests', () => {
  // Mock EventSource for browser environment
  let mockEventSource: any;
  let eventHandlers: Record<string, Function> = {};

  beforeAll(() => {
    // Create a mock EventSource
    mockEventSource = vi.fn().mockImplementation((url: string) => {
      return {
        url,
        readyState: 0, // CONNECTING
        addEventListener: vi.fn((event: string, handler: Function) => {
          eventHandlers[event] = handler;
        }),
        removeEventListener: vi.fn(),
        close: vi.fn(),
        onerror: null,
        onmessage: null,
        onopen: null,
      };
    });

    // Set it globally
    (global as any).EventSource = mockEventSource;
  });

  afterAll(() => {
    delete (global as any).EventSource;
  });

  describe('SSE Connection', () => {
    it('should establish SSE connection with correct headers', async () => {
      const mockFetch = vi.fn().mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Headers({
          'content-type': 'text/event-stream',
          'cache-control': 'no-cache',
          connection: 'keep-alive',
        }),
        body: new ReadableStream({
          start(controller) {
            controller.enqueue(new TextEncoder().encode('event: message_start\ndata: {"id":"test-1"}\n\n'));
            controller.close();
          },
        }),
      });

      global.fetch = mockFetch;

      // Simulate SSE request
      const response = await fetch(`${ARCHESTRA_SERVER_BASE_URL}/api/agent/chat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: [{ role: 'user', content: 'Test message' }],
        }),
      });

      expect(mockFetch).toHaveBeenCalledWith(
        `${ARCHESTRA_SERVER_BASE_URL}/api/agent/chat`,
        expect.objectContaining({
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        })
      );

      expect(response.headers.get('content-type')).toBe('text/event-stream');
      expect(response.headers.get('cache-control')).toBe('no-cache');
    });
  });

  describe('SSE Event Parsing', () => {
    it('should parse message_start event correctly', () => {
      const events: any[] = [];
      const parseSSEEvent = (data: string) => {
        const lines = data.split('\n');
        const event: any = {};

        for (const line of lines) {
          if (line.startsWith('event:')) {
            event.type = line.substring(6).trim();
          } else if (line.startsWith('data:')) {
            event.data = JSON.parse(line.substring(5).trim());
          }
        }

        if (event.type && event.data) {
          events.push(event);
        }
      };

      const sseData = `event: message_start
data: {"id":"msg-123","role":"assistant","content":[],"model":"ollama"}

event: content_delta
data: {"delta":{"type":"text_delta","text":"H"},"index":0}

event: content_delta
data: {"delta":{"type":"text_delta","text":"ello"},"index":1}
`;

      sseData.split('\n\n').forEach((chunk) => {
        if (chunk.trim()) {
          parseSSEEvent(chunk);
        }
      });

      expect(events).toHaveLength(3);
      expect(events[0]).toEqual({
        type: 'message_start',
        data: {
          id: 'msg-123',
          role: 'assistant',
          content: [],
          model: 'ollama',
        },
      });
      expect(events[1].type).toBe('content_delta');
      expect(events[2].data.delta.text).toBe('ello');
    });

    it('should parse data_part events with reasoning', () => {
      const parseSSEData = (data: string) => {
        try {
          return JSON.parse(data);
        } catch {
          return null;
        }
      };

      const reasoningEvent = `event: data_part
data: {"part":{"type":"data","data":{"type":"reasoning","entry":{"id":"r-1","type":"planning","content":"Analyzing request","confidence":0.9}}}}`;

      const lines = reasoningEvent.split('\n');
      let eventType = '';
      let eventData: any = null;

      for (const line of lines) {
        if (line.startsWith('event:')) {
          eventType = line.substring(6).trim();
        } else if (line.startsWith('data:')) {
          eventData = parseSSEData(line.substring(5).trim());
        }
      }

      expect(eventType).toBe('data_part');
      expect(eventData.part.type).toBe('data');
      expect(eventData.part.data.type).toBe('reasoning');
      expect(eventData.part.data.entry.content).toBe('Analyzing request');
    });

    it('should parse task progress events', () => {
      const progressEvent = {
        event: 'data_part',
        data: {
          part: {
            type: 'data',
            data: {
              type: 'task_progress',
              progress: {
                completed: 5,
                total: 10,
                currentStep: 'Processing files',
                percentComplete: 50,
              },
            },
          },
        },
      };

      expect(progressEvent.data.part.data.type).toBe('task_progress');
      expect(progressEvent.data.part.data.progress.percentComplete).toBe(50);
    });
  });

  describe('Error Recovery', () => {
    it('should handle connection errors gracefully', async () => {
      const mockFetch = vi.fn().mockRejectedValue(new Error('Network error'));
      global.fetch = mockFetch;

      try {
        await fetch(`${ARCHESTRA_SERVER_BASE_URL}/api/agent/chat`, {
          method: 'POST',
          body: JSON.stringify({ messages: [] }),
        });
      } catch (error) {
        expect(error).toEqual(new Error('Network error'));
      }
    });

    it('should handle malformed SSE data', () => {
      const parseSSE = (data: string) => {
        try {
          if (!data.includes(':')) return null;
          const colonIndex = data.indexOf(':');
          const field = data.substring(0, colonIndex);
          const value = data.substring(colonIndex + 1);
          if (field === 'data') {
            return JSON.parse(value.trim());
          }
          return null;
        } catch {
          return null;
        }
      };

      expect(parseSSE('invalid data')).toBeNull();
      expect(parseSSE('data: {invalid json}')).toBeNull();
      expect(parseSSE('data: {"valid": "json"}')).toEqual({ valid: 'json' });
    });

    it('should implement retry logic on connection failure', async () => {
      let attemptCount = 0;
      const maxRetries = 3;

      const retrySSEConnection = async (_url: string, _options: any) => {
        for (let i = 0; i < maxRetries; i++) {
          attemptCount++;
          try {
            if (attemptCount < 3) {
              throw new Error('Connection failed');
            }
            return { ok: true, status: 200 };
          } catch (error) {
            if (i === maxRetries - 1) throw error;
            await new Promise((resolve) => setTimeout(resolve, 100 * Math.pow(2, i)));
          }
        }
      };

      const result = await retrySSEConnection('/test', {});
      expect(attemptCount).toBe(3);
      expect(result).toEqual({ ok: true, status: 200 });
    });
  });

  describe('Abort Handling', () => {
    it('should support request cancellation', () => {
      const controller = new AbortController();
      const signal = controller.signal;

      const mockFetch = vi.fn().mockImplementation(() => {
        return new Promise((resolve, reject) => {
          signal.addEventListener('abort', () => {
            reject(new DOMException('Aborted', 'AbortError'));
          });

          // Simulate ongoing request
          setTimeout(() => {
            resolve({ ok: true });
          }, 1000);
        });
      });

      global.fetch = mockFetch;

      const requestPromise = fetch('/test', { signal });

      // Abort after 50ms
      setTimeout(() => controller.abort(), 50);

      return expect(requestPromise).rejects.toThrow('Aborted');
    });

    it('should clean up EventSource on abort', () => {
      const eventSource = new EventSource('/test');
      const closeSpy = vi.spyOn(eventSource, 'close');

      // Simulate abort
      eventSource.close();

      expect(closeSpy).toHaveBeenCalled();
    });
  });

  describe('Stream Processing', () => {
    it('should accumulate content from multiple content_delta events', () => {
      const contentDeltas = [
        { delta: { type: 'text_delta', text: 'Hello' }, index: 0 },
        { delta: { type: 'text_delta', text: ' ' }, index: 1 },
        { delta: { type: 'text_delta', text: 'world' }, index: 2 },
        { delta: { type: 'text_delta', text: '!' }, index: 3 },
      ];

      let accumulatedContent = '';
      contentDeltas.forEach((event) => {
        accumulatedContent += event.delta.text;
      });

      expect(accumulatedContent).toBe('Hello world!');
    });

    it('should handle tool call events in sequence', () => {
      const events = [
        {
          type: 'tool_call_start',
          data: {
            tool_call: {
              id: 'call-1',
              name: 'search_files',
              arguments: { query: 'test' },
            },
          },
        },
        {
          type: 'tool_call_result',
          data: {
            tool_call_id: 'call-1',
            result: {
              success: true,
              data: 'Found 5 files',
            },
          },
        },
      ];

      const toolCalls = new Map();

      events.forEach((event) => {
        if (event.type === 'tool_call_start') {
          if (event.data.tool_call) {
            toolCalls.set(event.data.tool_call.id, {
              ...event.data.tool_call,
              status: 'pending',
            });
          }
        } else if (event.type === 'tool_call_result') {
          const call = toolCalls.get(event.data.tool_call_id);
          if (call) {
            call.status = 'completed';
            call.result = event.data.result;
          }
        }
      });

      const call = toolCalls.get('call-1');
      expect(call.status).toBe('completed');
      expect(call.result.data).toBe('Found 5 files');
    });
  });

  describe('DevTools Network Tab Visibility', () => {
    it('should show SSE events in proper format for DevTools', () => {
      // SSE format that DevTools can parse
      const sseFormat = (event: string, data: any) => {
        return `event: ${event}\ndata: ${JSON.stringify(data)}\n\n`;
      };

      const message = sseFormat('message_start', { id: '123', role: 'assistant' });

      expect(message).toContain('event: message_start');
      expect(message).toContain('data: ');
      expect(message).toMatch(/\n\n$/); // Double newline at end
    });

    it('should include proper SSE headers for DevTools inspection', () => {
      const headers = {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        Connection: 'keep-alive',
        'X-Accel-Buffering': 'no', // Disable proxy buffering
      };

      expect(headers['Content-Type']).toBe('text/event-stream');
      expect(headers['X-Accel-Buffering']).toBe('no');
    });
  });

  describe('Keepalive and Timeouts', () => {
    it('should handle keepalive ping events', () => {
      const events = [
        { type: 'ping', data: {} },
        { type: 'content_delta', data: { delta: { text: 'test' } } },
        { type: 'ping', data: {} },
      ];

      const contentEvents = events.filter((e) => e.type !== 'ping');
      expect(contentEvents).toHaveLength(1);
      expect(contentEvents[0].type).toBe('content_delta');
    });

    it('should detect connection timeout', async () => {
      const TIMEOUT_MS = 30000; // 30 seconds
      let lastEventTime = Date.now();

      const checkTimeout = () => {
        const now = Date.now();
        return now - lastEventTime > TIMEOUT_MS;
      };

      // Simulate event received
      lastEventTime = Date.now();
      expect(checkTimeout()).toBe(false);

      // Simulate timeout
      lastEventTime = Date.now() - 31000;
      expect(checkTimeout()).toBe(true);
    });
  });
});
